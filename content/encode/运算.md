---
title: 2.3 运算方法和电路
type: docs
weight: 3
---

# 运算方法和电路

## 运算部件

`ALU`：Arithmetic and Logic Unit，能进行加减运算、逻辑运算和一些移位、取补的操作（控制信号指明）

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230702205005166.png" alt="image-20230702205005166" style="zoom:80%;"/>

门电路实现与或非

优先级：与 > 或

异或门实现加法运算

宏观来看一个加法器应该是这样：

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230704160232267.png" alt="image-20230704160232267" style="zoom:67%;" />

### 电路实现

**一位全加器**
{{< katex display>}}
S_i = A_i \oplus B_i \oplus C_{i-1} \\
C_i = A_i B_i + (A_i \oplus B_i)C_{i-1}
{{< /katex >}}



{{< expand "电路设计" >}}

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230702222005491.png" alt="image-20230702222005491" style="zoom:80%;" />

{{< /expand >}}

**串行进位全加器**

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230702221927526.png" alt="image-20230702221927526" style="zoom:90%;" />

**并行进位加法器**

对进位的公式进行了展开，发现了可以进行超前进位的特点，即：

> {{< katex>}}C_i{{< /katex >}} 只与 {{< katex>}}\{A_i\}{{< /katex >}}，{{< katex>}}\{B_i\}{{< /katex >}}和{{< katex>}}C_0{{< /katex >}}有关
>
> 一般定义 {{< katex>}}G_i = A_i B_i, \quad P_i = A_i \oplus B_i{{< /katex >}}

`CLA`部件实现对进位的超前计算，全先行进位加法器的组成：

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230704155705232.png" alt="image-20230704155705232" style="zoom:80%;" />

{{< expand "CLA部件的电路" >}}

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230704155810400.png" alt="image-20230704155810400" style="zoom:80%;" />

可发现位数越高电路越复杂，一般也就到4位

{{< /expand >}}

**带标志位的加法器**

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230704162324221.png" alt="image-20230704162324221" style="zoom:80%;"  align = "right"/>

定义了四个标志位：

- 溢出标志`OF`：最高位的进位{{< katex>}}C_i\oplus{{< /katex >}}次高位的进位{{< katex>}}C_{i-1}{{< /katex >}}（只对于<u>有符号数</u>运算有意义）
- 符号标志`SF`: 即结果最高位，0表示为正，1为负 （只对于<u>有符号数</u>运算有意义）
- 进or借位标志`CF`: {{< katex>}}C_{out} \oplus C_{in}{{< /katex >}}，即最高位进位和运算符(0为+)的异或 （<u>无符号数</u>有意义）是对无符号数判断是否溢出的标志，而有符号数是看`OF`
- 零标志`ZF`: 结果全为0时为1

## 移位

### 算术移位（有符号数）

- 用原码：

即改变位权，对于定点数无法改变小数点位置，所以是向左向右补零，相当于乘除2

当定点整数向右移动，舍弃的是1时就意味着舍弃了精度

多想想这个表达式：

![image-20230704164147947](https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230704164147947.png)

同样也适用于定点小数

- 用反码：

负数由于取反，补的是1

- 用补码：

负数，最右边的1右边和原码一致，左边和反码一致，左右移动补的是不一样

总结：

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230704164650521.png" alt="image-20230704164650521" style="zoom:67%;" />

### 逻辑移位

讲操作数视为无符号数进行算术移位

### 循环移位

小循环：不带进位位`CF`

大循环：带上`CF`一起循环

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230704165144395.png" alt="image-20230704165144395" style="zoom:80%;" />

## 补码加减

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230704162806860.png" alt="image-20230704162806860" style="zoom:80%;" />

多路选择器`MUX`，运算控制信号进行选择，当为减法时选择 {{< katex>}}\bar{Y}{{< /katex>}} 然后进位 {{< katex>}}C_{in} = 1{{< /katex>}}，就实现了取反末位+1的处理

同样也可以用于无符号的加减运算

但是判断溢出的方法是不同的

## 乘除

### 原码一位乘法

符号位单独处理：取异或

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230704170242403.png" alt="image-20230704170242403" style="zoom:80%;" />



先加，然后逻辑右移，移到符号位为止

符号位要修改，ACC和MQ当中处符号位之外的一起



{{< details title="手算方式" open=true >}}
<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230704171150783.png" alt="image-20230704171150783" style="zoom:80%;" />
{{< /details >}}

### 补码一位乘法

`Booth算法`

MQ多一位辅助位在最后，ACC和X多一个双符号位在前面

## C语言类型转换



## 存储和排列