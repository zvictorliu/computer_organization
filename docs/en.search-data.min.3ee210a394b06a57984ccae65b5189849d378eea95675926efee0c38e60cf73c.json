[{"id":0,"href":"/computer_organization/cpu/%E6%8E%A7%E5%88%B6%E5%99%A8/%E7%A1%AC%E5%B8%83%E7%BA%BF/","title":"硬布线","section":"5.3 控制器","content":"\r硬布线设计方式\r#\r分析每个阶段的微操作序列 选择CPU的控制方式（定长机器周期，内含3个节拍） 安排微操作时序 先后顺序不能随意更改 被控对象不同的微操作尽量放在同一个节拍完成 时间短的微操作尽量放在一个节拍内完成，按先后顺序一条龙完成 电路设计（根据逻辑表达式设计电路） 操作时间表 最简逻辑表达式 电路 这样硬件设计的叫做硬布线，很快但是如果需要扩充指令就需要重新搭电路\n"},{"id":1,"href":"/computer_organization/encode/%E8%BF%90%E7%AE%97/%E5%8A%A0%E5%87%8F/","title":"加减","section":"2.3 运算方法和电路","content":"\r加法器\r#\r宏观来看一个加法器应该是这样：\n一位全加器\r#\r$$ S_i = A_i \\oplus B_i \\oplus C_{i-1} \\\\ C_i = A_i B_i + (A_i \\oplus B_i)C_{i-1} $$ 电路设计\r↕\r串行进位全加器\r#\r并行进位加法器\r#\r对进位的公式进行了展开，发现了可以进行超前进位的特点，即：\n$C_i$ 只与 ${A_i}$，${B_i}$和$C_0$有关\n一般定义 $G_i = A_i B_i, \\quad P_i = A_i \\oplus B_i$\nCLA部件实现对进位的超前计算，全先行进位加法器的组成：\nCLA部件的电路\r↕\r可发现位数越高电路越复杂，一般也就到4位\r带标志位的加法器\r#\r定义了四个标志位：\n溢出标志OF：最高位的进位$C_i\\oplus$次高位的进位$C_{i-1}$（只对于有符号数运算有意义） 符号标志SF: 即结果最高位，0表示为正，1为负 （只对于有符号数运算有意义） 进or借位标志CF: $C_{out} \\oplus C_{in}$，即最高位进位和运算符(0为+)的异或 （无符号数有意义）是对无符号数判断是否溢出的标志，而有符号数是看OF 零标志ZF: 结果全为0时为1 补码加减\r#\r多路选择器MUX，运算控制信号进行选择，当为减法时选择 $\\bar{Y}$ 然后进位 $C_{in} = 1$，就实现了取反末位+1的处理\n同样也可以用于无符号的加减运算\n但是判断溢出的方法是不同的\n"},{"id":2,"href":"/computer_organization/encode/%E8%A1%A8%E7%A4%BA/","title":"2.1 整数和定点小数编码","section":"第二章 编码","content":"\r整数和定点小数编码\r#\r无符号整数\r#\r​\t机器字长决定位数上限\n​\t减法运算：减数取反，末位加1后做加法\n带符号整数（定点整数）\r#\r原码与补码\r#\r原码：符号位+数值位\n​\t表示范围和个数（0的两种）\n​\t符号位不能参与运算，硬件电路很麻烦成本很高，所以发明了补码\n反码：中间状态\n​\t负数：符号位不变，数值位取反\n补码：\n​\t负数：反码末位+1\n手算的原码补码快速转换快速方法：从右往左第一个1的左边数值位取反\n补码计算\r#\r注意：负数的补码不表示权值，人类无法直接阅读\n加法：诸位相加即可，符号位也参与运算\n减法：取负（无论正负，全部位按位取反末位+1）（从右往左第一个1，左边全部位取反）\n​\t这一点和无符号的减法是一致的，同一套电路即可实现\n特性对比\r#\r补码的表示范围：\r\\( -2^n \\sim 2^n -1 \\)\r，因为补码形式下0只有一种形式：0,000000，而1,0000000表示 \\(-2^n \\)\r，但却没有对应的原码和反码，因此转换规则不使用（或者直接是按位取反溢出不舍弃）\n移码\r#\r补码的符号位取反，等价于\r\\(x\u0026#43;2^n\\)\r，所以其表示范围也是\r\\( -2^n \\sim 2^n -1 \\)\r从小到达排列与无符号一致，使得比大小很方便，一般用于浮点数阶码表示，且只能表示整数\n定点小数\r#\r小数点位置固定为定点数（隐含的并不是真的空出来一位，根据相对位置确定），不固定为浮点数\n定点小数：纯小数，小数点在最高位之前\n定点整数：纯整数，小数点在最低位之前\n定点小数可以用原码、反码、补码表示，而不能用移码\n表示方法和计算和无符号也是一样的，表示范围看上去就是定点整数\r\\(/2^n\\)\r，在形式上完全一致，这就使得计算机的处理方式不变而只需要不同的理解\n"},{"id":3,"href":"/computer_organization/mem/%E4%B8%BB%E5%AD%98/","title":"3.1 主存","section":"第三章 存储系统","content":"\r主存\r#\r基本组成\r#\r半导体 - 存储芯片 - 寻址方式支持\n存储元：1位，MOS管和电容的组成，需要恢复时间的原因\n一次性读取or写入多个存储元的数据\n存储元 - 存储单元 - 存储矩阵（存储体）\n整个存储字是同时被接通的\n读：译码器将MAR中的数据转换位某条路上的高电平，使得对应存储单元中存储元们同时被选择；然后通过数据线写入到MDR中，CPU通过数据总线从MDR中取走\n控制电路：确保电信号稳定后再操作；片选；读写区分\n逻辑上的组成：\n片选线：多个存储矩阵时区分，实际内存条内是有多个存储芯片\n引脚：地址线、数据线、片选线、控制线的接口，还有供电和接地的 （控制线可能为两根或一根）\n按字节编址，一个字节对应一个地址\n而寻址可以按字节、字、半字、双字\n当按字寻址时，通过逻辑右移实现一次性跨越多个字节\nRAM\r#\r动态DRAM：栅极电容，静态SRAM：双稳态触发器\nSRAM能够保持状态，读出不需要再生，非破坏，速度块，但构造复杂成本高、面积大、功耗大；cache一般用这个\nDRAM则在读取后需要重写，是破坏性重写\n这两种芯片状态维持都需要电源，都是断电易失的\nDRAM还需要刷新：电容内电荷会随时间流失\nDRAM的刷新\r#\r行列地址方式： 减少选通线的数量\n一般一次刷新一行：硬件读取一行再写入\n每隔2ms进行一次刷新\n分散刷新：每次读写完就刷新一行 集中刷新：前面一直读取，之后留出时间来刷新，此时CPU无法访问，是为死区 异步刷新：在周期内每行只刷新一次，每隔一定间隔就刷新一行 DRAM还有地址线复用技术减少地址线（因为DRAM一般地址空间更大）：行地址和列地址分两次传入，先传入行，再存入列\n而SRAM地址空间小，就一次性传入\nROM\r#\r以下并不是说这属于主存\nMROM 掩模式只读存储器：厂家生产时写入之后无法更改\nPROM 可编程只读存储器，用户能写一次\nEPROM 可擦除课编程只读存储器，用户也能多次写入但比较麻烦\n​\tUVEPROM：紫外线方式，一次性擦除所有信息\n​\tEEPROM：电擦除特定的字\nFlash Memory 闪存：在EEPROM之上发展而来，擦除更快，但是写之前还是需要擦一遍，写会慢于读（比如U盘和SD卡）；它的存储元是单个MOS管，位密度比RAM高\nSSD固态硬盘：在闪存的基础上还有了控制单元\n所以现在说的ROM还真不是纯粹的read only，ROM也可能是随机存取的\n主板上的ROM芯片如BIOS芯片，也划在主存范围内，所以主存不只有内存(RAM)\n多模块技术\r#\r解决CPU的速度和主存的速度（受制于DRAM的长恢复时间）匹配问题 $$ 存储周期T = 存取时间r + 恢复时间 $$\n多体并行\r#\r多个模块，每个模块有各自的控制电路和寄存器\n高位交叉编址：体号+体内地址\n这种连续的单元在同一体内仍然是顺序的\n低位交叉编址：体号放后面低地址，这种才是交叉的\n这种则连续的单元并不是在同一体内\n模块数的确定：\nr为存取时间或总线传输周期（看哪个大）\n加装内存条就可以考虑是高位交叉（单纯扩容）还是低位交叉（双通道）\n单体多字\r#\r只有一个存储体，一次读取一整个存储单元（一整行），一个存储单元内有多个字\n灵活性要更差，当读取的内容跨越了一行后就需要读两次\n"},{"id":4,"href":"/computer_organization/command/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F/","title":"4.1 指令格式","section":"第四章 指令系统","content":"\r指令格式\r#\r这几个分类依据：\n地址码数目\r#\r零指令：可能是不需操作数的指令，也可能只是不需要显示给出的（堆栈）\n一地址：同样可能是单操作数，也可能是隐含在某寄存器中，实际还是两个操作数\n二地址：目的操作数也同时是结果保存的地方\n三地址：结果另外保存\n四地址：第4个是下一步指令的地址，进行跳转\n这里我们说“地址码的数目”指的是这个意思，而非位数\n另外还要注意别混淆 指令 和 操作码\n指令长度\r#\r机器字长：一次整数运算能处理的位数\n存储字长：存储单元的长度\n指令字长：指令的长度\n半字长指令、单字长指令、双字长指令，指相对于机器字长\n指令字长可变的，指令系统分定长指令字结构合变长指令字结构\n操作码长度\r#\r按照操作码的长度可变性（不是指令的长度可变性）分类\n定长操作码：n位代表$2^n$种不同的指令\n可变长操作码\n扩展操作码指令格式\r#\r指令字长固定+操作码长度可变\n1111留作扩展操作码使用\n​\t能够通过检查判断出是几地址\n​\t为1111说明还有，不是则说明操作码到此为止\n这样保证了短码不会成为长码的前缀\n先通过地址码位数固定操作码的位数来看\n操作类型\r#\r数据传送\n算术和逻辑运算\n移位\n转移：改变程序执行流\n输入输出：和IO端口的数据交换\n"},{"id":5,"href":"/computer_organization/cpu/%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/","title":"5.1 指令执行过程","section":"第五章 中央处理器","content":"\r指令执行过程\r#\r指令周期\r#\r取、译码（很快）、执行，将译码也分在取指令周期内：\nCPU周期和CPU时钟周期不是一个意思\nCPU周期又叫机器周期，一个指令周期需要多个机器周期，一个多个机器周期需要多个时钟周期（又叫节拍），主频也是描述的这个\n不同指令的指令周期的长度可能是不同的：\n整个流程是：\n设置了几个触发器来判断处于哪个阶段，不同阶段的任务、理解不同\n取指周期\r#\r(PC) -\u0026gt; MAR\nCU发出读控制信号：1 -\u0026gt; R\nM(MAR) -\u0026gt; MDR，(MDR) -\u0026gt; IR\nCU发出控制信号，使得(PC)+1 -\u0026gt; PC\n间址周期\r#\r复制得到有效地址，并不取出操作数\n将地址码送入MAR，可以从IR中得到也可以从MDR中得到，Ad(IR) -\u0026gt; MAR CU发出读信号 \u0026hellip; （将有效地址送给地址码） 执行周期\r#\r不同指令的执行周期不同\n中断周期\r#\r执行完后都会进行中断检查，如有则执行中断程序\nSP存的是地址，SP-1后即为PC指要放入的地址\n(SP)-1 -\u0026gt; SP，(SP) -\u0026gt; MAR，1 -\u0026gt; W，(PC) -\u0026gt; MDR\n然后修改PC：向量地址 -\u0026gt; PC\n指令执行方案\r#\r单指令周期：串行执行，统一时间，木桶效应 多指令周期：不要求定长 流水线：没有冲突的硬件情况下，可以并行，交错一些阶段 "},{"id":6,"href":"/computer_organization/bus/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84/","title":"6.1 总线结构","section":"第六章 总线","content":"\r系统总线结构\r#\r单总线结构\n争用、不能多个设备并行发送，带宽低；速度不匹配\n双总线结构\n通道对IO设备的管理（也是一种控制器，也有通道程序存在主存）\n支持突发传输（传输一个地址得到连续的多个数据）\n三总线结构\nDMA进行传输，缓和速度矛盾\nIO设备对CPU的响应也更快，无需经过通道\n补充：现代的四总线结构\r↕\r桥接器用做数据缓冲和转换、以及仲裁分配总线使用权\r"},{"id":7,"href":"/computer_organization/introduction/","title":"第一章 绪论","section":"序","content":"\r绪论\r#\r计算机系统\r#\r计算机系统=硬件+软件，系统的性能主要由软件的效率表征，而软件的发挥与硬件有关\n软件与硬件在逻辑上等效，但硬件实现性能更好\n存储程序概念：指令以二进制形式送入主存，一旦启动就不需要人为干预，自动逐条执行指令\n冯·罗依曼体系结构：\n输入输出设备进行人识别信息-机器识别信息转换\n控制器执行指令的解析，运算器完成运算，指令和数据存放在存储器\n冯以运算器为中心，输入输出都需要经过运算器，影响了效率，所以现代计算机是以存储器为中心：\nCPU = 控制器+运算器，主机不包含辅助存储器（外存是外设）\n层次结构\r#\r计算机系统的多级层次结构，上层看上去是在直接操控计算机\n微指令：理解为硬件的动作\n高级语言 - 汇编语言 - 机器语言\n汇编器：汇编到机器语言 编译器：高级到汇编，有些可以直接到机器语言 解释器：将语句逐条翻译为机器指令（类似同声传译）然后执行，是命令行式的，Python就是这样只不过是脚本的形式 PC存放下一条指令的地址，IR存放当前的指令，从PC到IR需要MDR（存放欲访问的内存地址——，MIR暂存读出来的指令\n性能指标\r#\r主存容量：MAR位数（存储单元个数）和MDR位数（存储单元大小）\n运算速度：\nCPU主频：主时钟信号频率 CPU时钟周期不同于CPU周期（机器周期） CPI, Clock cycle Per Instruction：一条指令需要多少个时钟周期（一般看平均） CPU执行时间 IPS, Instrutions Per Second：每秒执行多条指令 （MIPS，每秒多少百万条） FLOPS, Floating-point Operations Per Second：每秒多少浮点操作 吞吐量：单位时间处理请求的数量（每种请求每钟吞吐量 响应时间 数据通路带宽：数据总线一次能并行传输的信息位数\n字长：进行一次整数运算所处理的二进制数据位数，一般看通用寄存器\n机器字长就是计算机位数，不同于操作系统位数（寻址） 基准程序：跑分软件，跑相同的代码比较性能\n"},{"id":8,"href":"/computer_organization/cpu/%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BE%AE%E7%A8%8B%E5%BA%8F/","title":"微程序","section":"5.3 控制器","content":"\r微程序设计方式\r#\r将微操作也进行程序化\n微指令序列构成一个微程序（一条微指令可能包含多个微命令，一个微命令对应一个微操作）\n在CPU出厂前，把所有指令的微程序存入一个控制器存储器中，CPU执行一个指令实际在执行其对应的微程序，包括一条条微指令\n这样可以减少电路的复杂性\n所以一条微指令的基本格式设计为：\n操作控制+顺序控制（下一条微指令的地址）\n工作原理\r#\r操作码送到微地址形成部件，确定对应微程序的位置\n主要是指令周期的几个阶段所用的微指令有很大重复性\n指令系统的不同指令至少有一个重复的微程序：都需要取指令，每条指令独特的在于其执行周期，而取指、间址、中断的微指令序列一般是一样的用的公同一个微程序（段）\n所以是$n$种机器指令对应至少$n+1$个微程序（段）\n但是“一条指令对应一个微程序”的说法也对，是把它们看作了一个整体\n微指令设计\r#\r如何根据微指令发出相应的微命令（控制信号）？\n格式应该如何设计？\n微命令可以相容互斥\n水平型：多个并行的微命令 垂直型：一条只能对应一个微命令 混合型：垂直型加上一点不那么多的混合 控制信号的形成：\n直接控制：一个比特位对应一个微命令 ​\t字段直接编码：控制字段分段，每段译码发出控制信号，互斥的放在同一段内\n字段间接编码：两层译码\n地址：\n下地址直接指出（断定方式） 根据操作码形成 增量计数器法 (CMAR)+1 -\u0026gt; CMAR 分支转移 测试网络 硬件产生微程序入口地址 微程序控制单元的设计\r#\r指令的微操作序列 节拍安排 确定微指令格式 考虑如何读出微指令，如何转入下一个机器周期 取指周期的第一条微指令放的位置是固定的\n相比之下比硬布线要慢\n"},{"id":9,"href":"/computer_organization/encode/%E8%BF%90%E7%AE%97/%E7%A7%BB%E4%BD%8D/","title":"移位","section":"2.3 运算方法和电路","content":"\r移位\r#\r算术移位（有符号数）\r#\r用原码： 即改变位权，对于定点数无法改变小数点位置，所以是向左向右补零，相当于乘除2\n当定点整数向右移动，舍弃的是1时就意味着舍弃了精度\n多想想这个表达式：\n同样也适用于定点小数\n用反码： 负数由于取反，补的是1\n用补码： 负数，最右边的1右边和原码一致，左边和反码一致，左右移动补的是不一样\n总结：\n逻辑移位\r#\r讲操作数视为无符号数进行算术移位\n循环移位\r#\r小循环：不带进位位CF\n大循环：带上CF一起循环\n"},{"id":10,"href":"/computer_organization/encode/%E6%B5%AE%E7%82%B9%E6%95%B0/","title":"2.2 浮点数","section":"第二章 编码","content":"\r浮点数\r#\r从科学计数法的思想而来\n表示\r#\r\\[\rN = 尾数M \\times 基数r^{阶码E}\r\\]\r基数隐含是规定值，一般是2\n尾数是定点小数，表现精度；阶码用以推算小数点位置，表现大小\n规格化\r#\r10进制中要求尾数的第一个数为有效值，小数点在其后，在2进制中：\n左规：尾数算术左移直到 第一位（除符号位为）为1，每移动1位阶码也要相应-1 右规：在运算时有效位走到小数点之前，所以需要右移，减小尾数增大阶数 运算\r#\r"},{"id":11,"href":"/computer_organization/mem/%E4%B8%BB%E5%AD%98%E4%B8%8Ecpu%E8%BF%9E%E6%8E%A5/","title":"3.2 主存与CPU连接","section":"第三章 存储系统","content":"\r主存与CPU连接\r#\r这样的基本连接模型：\n当CPU的DB和AB长度和存储器不一致时，需要进行扩展：\n​\t字扩展：增大存储单元数量\n​\t位扩展：增大存储芯片字长\n单块\r#\r一块存储芯片：\n地址线\u0026ndash;存储单元个数，数据线\u0026ndash;存储字长，控制线，片选线\n而经常是总线数量比接口多，于是有位扩展和字扩展\n多块\r#\r位扩展\r#\r每块只有一位 ($8K \\times 1 bit$)，合起来\n字扩展\r#\r扩展容量（AB比地址接口多，寻址能力没有充分发挥）\n取高位地址为片选信号:\n​\t线选法：最直接的，有且只有一位使能，高位数量n对应块数量n，地址空间不连续（00 11这样的无效）\n​\t译码片选法：采用非门，能够利用的就更多了，高位数量n对应块数量$2^n$\n字位同时扩展\r#\r横向是字扩展，纵向是位扩展\n译码器\r#\rCPU的MAR送出地址信号，待稳定后CPU再发出存储器请求信号使能译码器，进一步使能存储器\n即译码器有多个使能同时作用才有效：\n说存储器容量表示为 xxB时是字数*字长的结果\n"},{"id":12,"href":"/computer_organization/command/%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80/","title":"4.2 寻址方式","section":"第四章 指令系统","content":"\r寻址方式\r#\r寻指令\r#\r永远是通过PC指向下一条要执行的指令\n顺序寻址\r#\rPC不一定是每次+1\n如果是按字编址且指令字长=存储字长的话才是+1\n而如果是按字节编址，两个字节的指令字长，每次是+2\n而如果是变指令字长就更复杂了：需要先读入一个字判断出指令字长\n但是依然会说PC+1，这里的1指的是1个指令字长\n跳跃寻址\r#\r通过本次指令告诉计算方式，修改PC\n具体来说，当取出一条转移指令，仍然会PC+1，执行后PC被更改（它这个指令的行为就是修改PC）\n寻数据\r#\r由地址码确定真实的物理地址(有效地址EA)\n对地址码有不同的解读方式，地址码包括寻址特征位和形式地址A\n直接寻址\r#\rA即为绝对地址，$EA=A$\n访存：取指令1次，执行（找数据）1次，(结果存放在寄存器中不算)\n寻址范围小，且不容易随地址变化而变化\n间接寻址\r#\rA是存放有效地址的存储单元的地址，即$EA=(A)$\n访存：取1次，找数据2次\n甚至还可以是多级的：\n这样寻址范围就变大了\n寄存器(直接)寻址\r#\rA为寄存器编号，访问的是寄存器，寄存器存EA\n寄存器间接寻址\r#\r隐含寻址\r#\r这实际是指的是隐含的操作数寻址\n立即(数)寻址\r#\r操作数直接给出了，A不代表地址，就代表操作数本身\n（一般会用一个#来标识）\n相对寻址\r#\r相对于PC的偏移量\n这里的PC是加了之和的，即相对于下一条指令的地址\n适合挪动循环代码在程序中的位置时用\n基址寻址\r#\r相对于基址寄存器BR, base register的内容\n可能计算机没有专用的BR，用通用寄存器代替\nBR内容是操作系统管理的，一般是程序段的起始\n变址寻址\r#\r变址寄存器IX, index register的内容+A（严格来说是IX相对于A）\n用户就可以修改IX\n面向用户，适合循环程序，主要用于数组：A为数组首地址\n基址变址复合：BR+AX为基地址\nIX为偏移量\n堆栈寻址\r#\r堆栈操作，操作数存在堆栈中，隐含使用堆栈指针寄存器SP\nSP指向栈顶\n硬堆栈：存在寄存器 软堆栈：存在主存 出栈：SP指向栈顶，读元素\n入栈：SP先加1再写入元素\n这些也是系统完成的\n"},{"id":13,"href":"/computer_organization/cpu/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/","title":"5.2 数据通路","section":"第五章 中央处理器","content":"\r数据通路\r#\r数据的流动\n微操作信号发生器 发生不同的控制信号，使得数据流动\n数据流动方向\r#\r寄存器之间\r#\r本质上是电路，CU的控制信号选择开关决定能流向哪里\nPCout有效，(PC) -\u0026gt; Bus\nMARin有效，Bus -\u0026gt; MAR\n主存与CPU之间\r#\rCU需要发出 读or写信号，一般没有画出但需要知道\n算术逻辑运算\r#\rALU需要两个操作数，但是单总线结构同时只能传一个，孤儿有暂存寄存器Y，先把一个传到Y，Y和ALU直接相连，再把另一个传给ALU\n每一个微操作至少花费一个时钟周期\n()表示内容，也可能表示间接寻址\n(PC)+1 -\u0026gt; PC 是自动完成的，一般不经过ALU，没有去考虑它的控制信号\n专用数据通路\r#\r直接连接，不会有冲突，但是要多路的选择\n"},{"id":14,"href":"/computer_organization/bus/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/","title":"6.2 性能指标","section":"第六章 总线","content":"\r性能指标\r#\r总线周期：申请 - 寻址 - 传输 - 结束，即一次总线操作所需要的时间\n工作频率：1 / 总线周期\n总线时钟周期：机器的时钟周期（现代的可能是桥接器的时钟周期），和总线周期不一样\n总线时钟频率\n总线宽度：一般指数据总线的根数\n总线带宽：数据传输率，单位时间内可以传输多少bit或者字节的数据\n有效数据传输速率不包括校验位那些bit\n总线复用\n信号线数：三种总线数的总和\n(1)\n每个时钟周期传两次数据，意思就是一个时钟周期=2个总线周期\n工作频率为 $2 \\times 66MHz$，宽度为32位，所以带宽是 $32 * 2 * 66MHz$\n(2)\n传地址占一个时钟周期（突发只传一次）\n传128位数据，宽度为32位所以需要传4次即4个总线周期，即2个时钟周期\n一个三个时钟周期\n"},{"id":15,"href":"/computer_organization/encode/","title":"第二章 编码","section":"序","content":"\r数据的表示和运算\r#\r进位计数\n进制转换：\n二进制与8进制、16进制（三位，四位一组） 10进制转： 整数部分：除K取余 小数部分：乘K取整 真值：带正负的数\n机器数：数字化后的真值\n"},{"id":16,"href":"/computer_organization/encode/%E8%BF%90%E7%AE%97/%E4%B9%98%E9%99%A4/","title":"乘除","section":"2.3 运算方法和电路","content":"\r乘法\r#\r原码一位乘法\r#\r符号位单独处理：取异或\n先加，然后逻辑右移，移到符号位为止\n符号位要修改，ACC和MQ当中处符号位之外的一起\n手算方式\r补码一位乘法\r#\rBooth算法\nMQ多一位辅助位在最后，ACC和X多一个双符号位在前面\n在最后还会再加一次\n在电路上，有专门的辅助电路帮助进行\n除法\r#\r原码-恢复余数法\r#\r取绝对值进行计算，符号位单独来\n设商为1，进行减法计算，发现为负值，恢复余数，改为0\n逻辑左移\n原码-加减交替法\r#\r补码-加减交替法\r#\r双符号位参与计算\n最后一位商恒置为1\n天，这里怎么可能记得住\n"},{"id":17,"href":"/computer_organization/encode/%E8%BF%90%E7%AE%97/","title":"2.3 运算方法和电路","section":"第二章 编码","content":"\r运算方法和电路\r#\rALU：Arithmetic and Logic Unit，能进行加减运算、逻辑运算和一些移位、取补的操作（控制信号指明）\n门电路实现与或非\n优先级：与 \u0026gt; 或\n"},{"id":18,"href":"/computer_organization/mem/%E5%A4%96%E5%AD%98/","title":"3.3 外存","section":"第三章 存储系统","content":"\r外存\r#\r磁盘（机械硬盘）\r#\r写：电流方向控制磁头上极性变换，再有磁性记录介质\n读：切割磁感线\n是每1bit的读写，且不能同时进行\n非破坏性，介质可重复使用，长期保存\n组成\r#\r盘片\n一个记录面对应一个磁头，盘面上一圈一圈图上介质，为磁道\n柱面号表示哪条磁道；扇区号表示哪个角度区间\n以扇区为单位（但是1位1位的）\n磁盘驱动器：驱动旋转\n磁盘控制器：与主机的接口，有常见标准SATA\n正反面都可以涂上：\n指标\r#\r容量：\n非格式化容量：物理上如果全用上的最大容量\n格式化容量：留出一些备份区间，能用的最大容量\n记录密度：\n道密度：磁道数/半径\n位密度：二进制码位数/磁道周长\n面密度：位密度*道密度\n每个扇区内的不同磁道的比特数是相等的，内侧位密度更大\n平均存取时间：\n寻道（磁头移动到对应磁道）$\\rightarrow$ 旋转延迟（定位到扇区）$\\rightarrow$ 传输时间，还可能算上控制命令的延迟\n一般未明说旋转延迟按平均来说：转半圈\n数据传输率：$D_r = 转速r \\times 磁道容量N$\n磁盘编址\r#\r驱动器号+磁道号+盘面号+扇区号\n盘面号激活哪个磁头（磁头是一列整体移动的）\n读写\r#\r总线并行，磁盘串行\n串并转换，一位一位读写\n磁盘阵列\r#\r廉价冗余磁盘阵列RAID\nRAID0：连续的数据分在相邻的磁盘上，能够提高速度（不总在一个磁盘上操作），能进行访问；但没有容错能力\nRAID1：镜像，安全性提高但减少了一般容量\nRAID2：存海明校验码而不存copy，RAID3-5就是其它的校验码，可靠性更高\nSSD（固态硬盘）\r#\r各个小芯片组成，基于闪存技术的EEPROM\n以页为单位进行读写：逻辑块对应SSD块当中的页\n按块擦除：当需要擦除某一页时是先把其它页复制到别的块再将整个块擦除\n而写之前必须擦除，是复制后写在新的页中，块号是会变化的，闪存翻译层会重新映射\n也支持随机访问（尽管是ROM），是电路定位，机械硬盘则不是时间均匀的（它写相对于读是慢的，但是相对于机械硬盘仍是很快的）\n缺点是：擦除过多会坏掉，而机械硬盘则不会\n闪存翻译层有一个平均磨损算法（迁移块时有考虑）\n​\t动态磨损均衡：每次迁移到磨损最少的块\n​\t静态磨损均衡：读多写少的数据放到比较老的块\n不过，实际上寿命还是很长的，并没有那么容易坏\n"},{"id":19,"href":"/computer_organization/command/%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/","title":"4.3 机器级表示","section":"第四章 指令系统","content":"\r程序的机器级代码表示\r#\r程序的高级语言和汇编语言和机器码的对应关系\n汇编语言：一般是x86\nx86汇编语言\r#\rx86: Intel 8086以及后面出来的兼容8086的CPU所用的指令集\n寄存器\r#\rE = Extended = 32bit\n前4个寄存器可以只使用起低16位：AX BX CX DX\n而这16位也可以单独使用高8位和低8位\nAccumulator\nBase Register\nCount Register\nData Register\n而变址寄存器 ESI EDI和堆栈寄存器 EBP BSP只能是32bit\n格式\r#\r格式有 AT\u0026amp;T格式(UNIX/Linux) 和 Intel格式(Windows)\nAT\u0026amp;T格式和 Intel格式的区别\r注意一个是 s d另一个是d s\n表示长度修饰：\nbyte ptr [xxx]: 8bit\nword ptr [xxx]: 16bit\ndword ptr [xxx]: 32bit\n即表示以所指地方开始的8/16/32位作为一个整体进行处理\n[ ]就表示操作数在主存中而不在寄存器中，xxx被理解为主存地址\n所以：\nxxx是数字：表示直接寻址 xxx是寄存器名：表示寄存器间接寻址，寄存器内是主存地址 如果没有修饰，默认是32bit\nxxx还可以是个表达式，表示地址的偏移，算出来的结果才是最终地址\n常见指令\r#\r数据传送：mov\tpush/pop 算术运算：add/sub mul/div imul/idiv(有符号) 逻辑运算：and/or/xor/neg shl/shr(逻辑左右移) 控制流：jmp j\u0026lt;condition\u0026gt;(最后一个运算结果的标志位) cmp/test call/ret 在x86中不允许两个操作数同时来自主存，所以一般要先调入寄存器\n选择语句实现\r#\r程序计算器PC也叫指令寄存器IP\n标号锚定位置：\n循环语句实现\r#\r此外还有loop指令，使用循环计数器ECX，自动\u0026ndash;\n过程调用（函数调用）\r#\r用到栈，每个函数有栈帧Stack Frame，保存局部变量和函数调用的相关信息\n正在运行的函数位于栈顶\n不过栈是从高地址到低地址的：\nEBP和ESP就是指向栈帧的底和顶，来表示栈帧的范围\n栈的访问：\n​\tpush让esp-4，然后把内容压入；pop先出栈复制到指定位置，再esp+4\n​\t这只能对栈顶操作，但对这两个寄存器用户是可操作的，可以用mov\n栈帧的切换：\n​\tcall先把IP旧值压入栈（esp也随之修改，相对于push)\n​\t调用：压入ebp的值，将esp设置为当前esp的内容，然后程序跳转后可能会再压入数据\n​\t​\t退出：让esp指向栈帧底部，再pop一下写入ebp，此时esp指向IP旧值，此时ret再修改IP\n在函数调用时会例行执行这些操作\n这些操作也可合并为 enter和leave指令\n栈底就是上一层的栈帧的基地址\n参数传递：\nEAX寄存器\n"},{"id":20,"href":"/computer_organization/cpu/%E6%8E%A7%E5%88%B6%E5%99%A8/","title":"5.3 控制器","section":"第五章 中央处理器","content":"\r控制器\r#\rCU每一个节拍就发出一个微命令，完成一个微操作\n同一个微操作在不同周期都可能出现\n简化设计：定长机器周期，即每种周期的长度相等，若实际永不了那么多，则先等待再在末尾的几个节拍执行\n现在需要知道如何根据各自信息在当前节拍需要发出什么样的微命令：\n仍是各种逻辑电路，当特定的输入后特定的C就会有效，这就控制了微操作的执行\n"},{"id":21,"href":"/computer_organization/bus/%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6/","title":"6.3 操作与定时","section":"第六章 总线","content":"\r操作与定时\r#\r操作：\n申请阶段：传输请求和总线仲裁\n寻址阶段\n传输阶段\n结束阶段：让出使用权\n这四个操作的时间配合即为总线定时\n同步通信\r#\r统一时钟控制数据传输\nT1：主设备发出地址信号\nT2：发出读命令，从设备根据地址和读命令知道是自己，于是赶紧准备数据（必须赶在T3上升沿之前）\nT3：从设备把数据放入总线\nT4：主设备撤销读命令\n这种强制性同步不能及时进行有效性校验；速度矛盾更明显\n异步通信\r#\r应答方式\n主设备发送请求，从设备发送应答\n不互锁\n主设备获得控制权后发出请求信号，等一段时间后就会撤销请求，同样从设备应答一段时间就会撤销，并不会一直等待\n半互锁\n主设备必须收到应答才会撤销请求，但从设备还是自动撤销\n全互锁\n都必须等待对方，即从设备也要等待主设备的请求撤销后才撤销应答信号\n补充\r↕\r半同步通信\r#\r统一时钟但是增加一个等待响应信号，当从设备准备好后才读\n分离式通信\r#\r慢速的从设备在准备数据时总线空闲\n于是在此阶段主设备就放弃总线控制权给其它设备，从设备准备好再申请控制权\n"},{"id":22,"href":"/computer_organization/mem/","title":"第三章 存储系统","section":"序","content":"\r存储系统\r#\r概述\r#\r存储器的分层次结构的意义：速度、容量\n存储器的分类\n性能指标：存取时间和存取周期的区别，需要恢复时间\n"},{"id":23,"href":"/computer_organization/mem/cache/","title":"3.4 cache","section":"第三章 存储系统","content":"\r高速缓冲存储器\r#\r将更常用的拿出来放到速度更快的地方（局部性原理）\n空间局部性：下一次需要到就在这次旁边\n时间局部性：下一次很可能用到同样的信息\nCPU优先去查找cache，有命中和不命中的可能，设命中概率为$H$ $$ t = Ht_c + (1-H)(t_c + t_m) $$ 而如果同时访问cache和主存，cache一旦找到就停下查找主存： $$ t = Ht_c + (1-H)t_m $$ 主存分块（也叫页），以块为单位进行交换\n​\t块号+块内地址\n每次在主存当中找到，就把所在块调入cache\ncache和主存的映射\r#\r主存块以何种规则放到cache块的哪个位置\n在cache中应当记录其来自何处：主存块号\n还应记录是否有效：有效位（块号是从0开始的，不能通过正数来区分）\n随意放：全相联映射\r#\r可以放到任何位置\n访存：由主存地址换算出块号，在cache中检索\n直接映射：固定位置\r#\r一般是块号余cache总块数\n如果cache总块数也是$2^n$那么可以直接通过主存块号的低$n$位来得到cache位置块号\n也因为这样，标记就不需要存末尾几位\n所以访存是将地址的块号的末尾几位去检查对应的cache块，就不需要检索了，主存地址理解为：标记位-cache块号-块内地址\n组相联：放到特定分组的任意位置\r#\r余组号\n主存地址理解为：标记位-cache组号-块内地址\nn路组相联：每n个cache为一组\n替换算法\r#\r全相联：全满后才会考虑替换\n直接映射：如果所属位置被占了那就直接替换它\n组相联：组满才考虑组内替换\nRAND：随机算法\nFIFO：\nLRU：最近最少使用\n计算器记录主存块多久没有被访问了\n细节：其余不变的意义\nLFU：最不经常使用\n反过来，将访问次数最少的换出，记录的是被访问过多少次\n出现相等时，FIFO或者行号递增的顺序\n需要很大的计数器；浓度影响\n写策略：一致性\r#\r当修改时，修改了cache中的副本，那么需要同步到主存\n写命中\r#\r写回法：只在改块被替换时（且是被修改过的）才写回主存，容易数据不一致\n全写法：修改cache同时也写主存\n这样会影响写的速度，于是设计之间有一个写缓冲，在专门的控制电路上逐一写回\n​\t​\t一旦满了就会阻塞\n写不命中\r#\r写分配法：先调入cache写，然后再用写回法 非写分配：直接往主存写，也可以搭配写缓冲的全写法，并不调入cache（只有读不命中才调入） 对于多级cache，在cache之间数据一致性要求高一些采用全写，而cache-主存则是写回\n"},{"id":24,"href":"/computer_organization/command/%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%90%91/","title":"4.4 CISC与RISC","section":"第四章 指令系统","content":"\rCISC与RISC\r#\r精简RISC：一条指令的功能尽可能基础，多条指令组合完成复杂功能\n​\t代表：ARM架构，一般用于手机平板\n​\t功耗低、设计简单\n复杂CISC：一条指令完成一个复杂的基本功能，用到一系列微指令来实现\n​\t代表：x86，一般用于PC和台式机\n就相当于C和Python的感觉\nCISC的问题：程序中80%的语句都只用到指令系统中20%的指令\n对比\r#\rRISC限制了访存，总需要LOAD/STORE来取写，需要更多的寄存器\nRISC一定要指令流水线\n"},{"id":25,"href":"/computer_organization/cpu/%E6%B5%81%E6%B0%B4%E7%BA%BF/","title":"5.4 指令流水线","section":"第五章 中央处理器","content":"\r指令流水线\r#\r对指令单纯串行执行顺序的优化\n没有硬件冲突的阶段\n设指令都分三个阶段，每个阶段时间长度相等\n顺序执行方式 一次重叠 执行阶段和下一条指令的取指令阶段没有冲突，就可以重叠\n只有第一条是完整的$3t$，而后每条实际只占$2t$\n二次重叠 这是比较理想的情况\n指令流程图\r用以分析影响因素 时空图\r用以评价性能\n性能指标\r#\r理想情况下：\n吞吐率TP：单位时间内完成的任务数量，一般就是指令的数量，一般用时空图比较好看 $$\rTP = \\frac{n}{(k+n-1)*\\Delta t}\r$$\r一般$\\Delta t$取一个时钟周期\r加速比S：同样一批任务不使用流水线与使用流水线的时间之比 $$ S = \\frac{T_0}{T_k} = \\frac{nk}{k+n-1} $$\n效率E：硬件设备的利用率\n红色区域内是处于忙碌阶段\n影响因素\r#\r典型的五段式划分：\n取指 - 译码 - 执行 - 访存 - 回写\n五个阶段的机器周期统一设置为最长耗时的那个\n为了补充多出来的时间不提前进入下一个阶段，在之间设置了缓冲寄存器暂存\n取指：从指令cache取，基本都能找到（姑且先认为都能找到吧），而且和数据cahce分开从而能够并行\n译码：还包括从通用寄存器取出操作数\nImm就是存立即数的\n写回：也有可能是写回寄存器\n冲突的可能性\r#\r结构相关（资源冲突） 各个阶段用到的硬件资源分别是：主存（把cache也当作主存了） - 寄存器 - ALU - 主存 - 寄存器\n冲突：\n解决办法：暂停等待 or 资源重复配置，比如指令和数据放到不同的两个cache中\nIm和Dm就不冲突了\n数据相关（数据冲突）：用到前面的内容，必须要等待前面的数据完成更新后才能进行访问\n一般是等待的办法：硬件阻塞或者软件插入空操作（编译器实现）\n数据旁路技术：在第一条数据算出来后直接送到下一个作为输入，不从寄存器中读\n编译器优化指令的顺序\n控制相关（控制冲突）\nPC值发生改变而造成指令断流\n跳转到了1000，而之间的这些本不应该被执行\n分支预测\n预取两种情况的目标指令\n提前形成条件码\n分类\r#\r部件功能级（算术逻辑运算层面的流水线）\n处理机级（指令流水线）\n处理机间级（更高层次的流水线，多个处理机共享存储器）\n单功能与多功能\n静态与动态\n线性与非线性\n多发技术\r#\r超标量技术（空分） 多个功能部件，并发多条独立指令（多个ALU这种）\n超流水技术（时分） 一个时钟周期再分段，一个功能部件使用多次(相当于更进一步划分)\n超长指令字 多条可以操作并行的指令组合成一条\n五段式指令流水线\r#\r不是每条指令都有5个段，单时间还是要消耗\n常见的五类指令：运算类、LOAD、STORE、条件转移、无条件转移\n运算类：\n取指，取出操作数（ID)，运算，写回\nRISC一定是把结果放到寄存器而不是直接放主存，故M为空\n跳过访存直接放到锁存器\nLOAD\nIF：取指令\nID：将基址寄存器的值放到锁存器A；将偏移量（立即数）放到Imm\nEX：计算得到有效地址\nM：取出数放入锁存器（一般不区分是cache还是主存，大多数情况都可以在cache中找到，因此一般是画的cache\nWB：写回寄存器\nSTORE\nIF取指令\nID：将基址寄存器的值放到锁存器A；将偏移量（立即数）放到Imm；此外还要把要存的数放到B\nEX：计算有效地址；将锁存器B的内容放到锁存器Store\nM：写入cache\nWB：不需要写入寄存器\n条件转移：\n若汇编格式是指出偏移量：jnz ax,bx,#偏移量\nIF取指令\nID：把用来比较的两个数放入A和B，把偏移量放入Imm\nEX：运算，比较\nM：修改PC值（并不是在WB阶段，PC都是尽可能早修改避免控制冲突）（偏移量是相对PC+1的）\nWB：空\n无条件转移\njmp #偏移量\nIF取指令，ID放偏移量，EX修改PC\nM和WB都为空\n"},{"id":26,"href":"/computer_organization/command/","title":"第四章 指令系统","section":"序","content":"\r指令系统\r#\r指令系统，即指令集\n操作码（内容）+地址码（对象，可缺省）\n"},{"id":27,"href":"/computer_organization/mem/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/","title":"3.5 虚拟存储器","section":"第三章 存储系统","content":"\r虚拟存储器\r#\r页式存储器\r#\r逻辑地址映射为物理地址：\n​\t页表：逻辑页号-主存页号\n页表本身也存在主存\n快表TLB：存在cache\n查一次慢表就升级为快表\n快表是一种内容式的相联存储器：根据页号直接定位到对应位置\n段式存储器\r#\r虚拟存储系统\r#\r不必整个应用程序调入内存\n内存“虚拟”着更大\n"},{"id":28,"href":"/computer_organization/cpu/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8/","title":"5.5 多处理器","section":"第五章 中央处理器","content":"\r多处理器\r#\r多处理器\r#\rSSID\r#\rSISD：单指令流单数据流，同一时刻内只能处理一两个数据\nSIMD\r#\rSIMD：单指令流多数据流，对结构类似的大量数据进行相同处理（图像处理分块处理）\n向量处理机：处理对象是以向量为单位的\n矩阵运算，向量ALU\nMISD\r#\rMISD：多指令流单数据流\n同时执行多条指令但处理同一个数据，实际不存在\nMIMD\r#\rMIMD：多指令流多数据流\n各个指令序列并行执行，各种处理不同的数据\n多处理器系统：右称共享内存多处理器、片级多处理器\n多计算机系统：\n硬件多线程\r#\r传统不支持多线程的处理器：需要保护现场存到主存\n而支持的就有多个寄存器组：\n细粒度多线程\r#\r多线程轮流交叉执行指令，可以乱序并行执行（指令级）\n每一个时钟周期切换一次线程\n粗粒度多线程\r#\r在一个线程出现了较大开销时才切换线程，指令级并行\n同时多线程\r#\r就是线程级完全并行执行\n"},{"id":29,"href":"/computer_organization/cpu/","title":"第五章 中央处理器","section":"序","content":"\rCPU\r#\r运算器+控制器\n功能\r#\rCPU的功能包括：\n指令控制（顺序性）\n操作控制（操作信号控制部件进行动作，即执行指令）\n时间控制\n数据加工（运算）\n中断处理\n结构\r#\r运算器\r#\rALU进行算术逻辑运算，它需要一些寄存器\n专用数据通路方式连接：\n同时应能选择哪个寄存器：多路选择器MUX、三态门\n单总线方式：为避免冲突，设置了暂存寄存器\n完整的是这样\r控制器\r#\r程序计数器PC：指明下一条指令的地址\n指令寄存器IR：保存当前正在执行的指令\n指令译码器ID：对操作码译码，向控制器提供特定操作的信号（不同指令的输出端不一样）\n微操作信号发生器：判断并生成对应的微操作序列\n时序信号控制下，还有标志和程序状态字寄存器PSW来控制下一步\n控制单元CU就是 ID、微操作信号发生器那部分\n用户可见的寄存器（汇编语言可以改变）：通用寄存器、PSW（条件转移、比较）、PC（JMP等，不是直接改）、ACC\n用户不可见：MAR、MDR、IR、暂存寄存器\n"},{"id":30,"href":"/computer_organization/bus/","title":"第六章 总线","section":"序","content":"\r总线\r#\r每个总线内部可能是多根信号线，所以是可以并行传输多少位的数据的\n同一时刻只能有一个部件发送（分时），而总线上多个设备都可以接收（共享）\n分类\r#\r串行总线：（如USB）\n并行总线：干扰会更明显\n注意串行并不一定比并行慢，带宽可能更高（频率影响）\n片内总线：CPU芯片内部的寄存器与寄存器、ALU之间的连接线 系统总线： 数组总线：位数与机器字长和存储字长相关 地址总线：和主存地址空间、设备数量（统一编址）有关，单向（CPU -\u0026gt; MEM） 控制总线：单根是单向的 通信总线：连接不同计算机 "},{"id":31,"href":"/computer_organization/io/","title":"第七章 IO系统","section":"序","content":"\rI/O系统\r#\r"},{"id":32,"href":"/computer_organization/encode/%E8%BF%90%E7%AE%97/%E5%85%B6%E5%AE%83/","title":"其它","section":"2.3 运算方法和电路","content":"\rC语言类型转换\r#\rC语言中定点整数都是补码表示（除非有unsigned）\n有符号和无符号转换：理解方式不一样而已\n不同字长：裁剪，符号扩展\n存储和排列\r#\r大小端模式\r#\r大端：MSB存入低地址\n小段：LSB存入低地址\n边界对齐\r#\r字地址和字节地址\n每次访存只能读写1个字\n空间换时间\n"}]