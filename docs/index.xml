<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>序 on Computer Organization</title>
    <link>https://zvictorliu.github.io/computer_organization/</link>
    <description>Recent content in 序 on Computer Organization</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language><atom:link href="https://zvictorliu.github.io/computer_organization/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://zvictorliu.github.io/computer_organization/encode/%E8%BF%90%E7%AE%97/%E5%8A%A0%E5%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/computer_organization/encode/%E8%BF%90%E7%AE%97/%E5%8A%A0%E5%87%8F/</guid>
      <description>加法器#宏观来看一个加法器应该是这样：
一位全加器#$$ S_i = A_i \oplus B_i \oplus C_{i-1} \\ C_i = A_i B_i + (A_i \oplus B_i)C_{i-1} $$ 电路设计↕串行进位全加器#并行进位加法器#对进位的公式进行了展开，发现了可以进行超前进位的特点，即：
$C_i$ 只与 ${A_i}$，${B_i}$和$C_0$有关
一般定义 $G_i = A_i B_i, \quad P_i = A_i \oplus B_i$
CLA部件实现对进位的超前计算，全先行进位加法器的组成：
CLA部件的电路↕可发现位数越高电路越复杂，一般也就到4位带标志位的加法器#定义了四个标志位：
溢出标志OF：最高位的进位$C_i\oplus$次高位的进位$C_{i-1}$（只对于有符号数运算有意义） 符号标志SF: 即结果最高位，0表示为正，1为负 （只对于有符号数运算有意义） 进or借位标志CF: $C_{out} \oplus C_{in}$，即最高位进位和运算符(0为+)的异或 （无符号数有意义）是对无符号数判断是否溢出的标志，而有符号数是看OF 零标志ZF: 结果全为0时为1 补码加减#多路选择器MUX，运算控制信号进行选择，当为减法时选择 $\bar{Y}$ 然后进位 $C_{in} = 1$，就实现了取反末位+1的处理</description>
    </item>
    
    <item>
      <title>2.1 整数和定点小数编码</title>
      <link>https://zvictorliu.github.io/computer_organization/encode/%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/computer_organization/encode/%E8%A1%A8%E7%A4%BA/</guid>
      <description>整数和定点小数编码#无符号整数#​	机器字长决定位数上限
​	减法运算：减数取反，末位加1后做加法
带符号整数（定点整数）#原码与补码#原码：符号位+数值位
​	表示范围和个数（0的两种）
​	符号位不能参与运算，硬件电路很麻烦成本很高，所以发明了补码
反码：中间状态
​	负数：符号位不变，数值位取反
补码：
​	负数：反码末位+1
手算的原码补码快速转换快速方法：从右往左第一个1的左边数值位取反
补码计算#注意：负数的补码不表示权值，人类无法直接阅读
加法：诸位相加即可，符号位也参与运算
减法：取负（无论正负，全部位按位取反末位+1）（从右往左第一个1，左边全部位取反）
​	这一点和无符号的减法是一致的，同一套电路即可实现
特性对比#补码的表示范围：\( -2^n \sim 2^n -1 \)，因为补码形式下0只有一种形式：0,000000，而1,0000000表示 \(-2^n \)，但却没有对应的原码和反码，因此转换规则不使用（或者直接是按位取反溢出不舍弃）
移码#补码的符号位取反，等价于\(x&amp;#43;2^n\)，所以其表示范围也是\( -2^n \sim 2^n -1 \)从小到达排列与无符号一致，使得比大小很方便，一般用于浮点数阶码表示，且只能表示整数
定点小数#小数点位置固定为定点数（隐含的并不是真的空出来一位，根据相对位置确定），不固定为浮点数
定点小数：纯小数，小数点在最高位之前
定点整数：纯整数，小数点在最低位之前
定点小数可以用原码、反码、补码表示，而不能用移码
表示方法和计算和无符号也是一样的，表示范围看上去就是定点整数\(/2^n\)，在形式上完全一致，这就使得计算机的处理方式不变而只需要不同的理解</description>
    </item>
    
    <item>
      <title>3.1 主存</title>
      <link>https://zvictorliu.github.io/computer_organization/mem/%E4%B8%BB%E5%AD%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/computer_organization/mem/%E4%B8%BB%E5%AD%98/</guid>
      <description>主存#基本组成#半导体 - 存储芯片 - 寻址方式支持
存储元：1位，MOS管和电容的组成，需要恢复时间的原因
一次性读取or写入多个存储元的数据
存储元 - 存储单元 - 存储矩阵（存储体）
整个存储字是同时被接通的
读：译码器将MAR中的数据转换位某条路上的高电平，使得对应存储单元中存储元们同时被选择；然后通过数据线写入到MDR中，CPU通过数据总线从MDR中取走
控制电路：确保电信号稳定后再操作；片选；读写区分
逻辑上的组成：
片选线：多个存储矩阵时区分，实际内存条内是有多个存储芯片
引脚：地址线、数据线、片选线、控制线的接口，还有供电和接地的 （控制线可能为两根或一根）
按字节编址，一个字节对应一个地址
而寻址可以按字节、字、半字、双字
当按字寻址时，通过逻辑右移实现一次性跨越多个字节
RAM#动态DRAM：栅极电容，静态SRAM：双稳态触发器
SRAM能够保持状态，读出不需要再生，非破坏，速度块，但构造复杂成本高、面积大、功耗大；cache一般用这个
DRAM则在读取后需要重写，是破坏性重写
这两种芯片状态维持都需要电源，都是断电易失的
DRAM还需要刷新：电容内电荷会随时间流失
DRAM的刷新#行列地址方式： 减少选通线的数量
一般一次刷新一行：硬件读取一行再写入
每隔2ms进行一次刷新
分散刷新：每次读写完就刷新一行 集中刷新：前面一直读取，之后留出时间来刷新，此时CPU无法访问，是为死区 异步刷新：在周期内每行只刷新一次，每隔一定间隔就刷新一行 DRAM还有地址线复用技术减少地址线（因为DRAM一般地址空间更大）：行地址和列地址分两次传入，先传入行，再存入列
而SRAM地址空间小，就一次性传入
ROM#以下并不是说这属于主存
MROM 掩模式只读存储器：厂家生产时写入之后无法更改
PROM 可编程只读存储器，用户能写一次
EPROM 可擦除课编程只读存储器，用户也能多次写入但比较麻烦
​	UVEPROM：紫外线方式，一次性擦除所有信息
​	EEPROM：电擦除特定的字
Flash Memory 闪存：在EEPROM之上发展而来，擦除更快，但是写之前还是需要擦一遍，写会慢于读（比如U盘和SD卡）；它的存储元是单个MOS管，位密度比RAM高
SSD固态硬盘：在闪存的基础上还有了控制单元
所以现在说的ROM还真不是纯粹的read only，ROM也可能是随机存取的
主板上的ROM芯片如BIOS芯片，也划在主存范围内，所以主存不只有内存(RAM)
多模块技术#解决CPU的速度和主存的速度（受制于DRAM的长恢复时间）匹配问题 $$ 存储周期T = 存取时间r + 恢复时间 $$</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zvictorliu.github.io/computer_organization/encode/%E8%BF%90%E7%AE%97/%E7%A7%BB%E4%BD%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/computer_organization/encode/%E8%BF%90%E7%AE%97/%E7%A7%BB%E4%BD%8D/</guid>
      <description>移位#算术移位（有符号数）#用原码： 即改变位权，对于定点数无法改变小数点位置，所以是向左向右补零，相当于乘除2
当定点整数向右移动，舍弃的是1时就意味着舍弃了精度
多想想这个表达式：
同样也适用于定点小数
用反码： 负数由于取反，补的是1
用补码： 负数，最右边的1右边和原码一致，左边和反码一致，左右移动补的是不一样
总结：
逻辑移位#讲操作数视为无符号数进行算术移位
循环移位#小循环：不带进位位CF
大循环：带上CF一起循环</description>
    </item>
    
    <item>
      <title>2.2 浮点数</title>
      <link>https://zvictorliu.github.io/computer_organization/encode/%E6%B5%AE%E7%82%B9%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/computer_organization/encode/%E6%B5%AE%E7%82%B9%E6%95%B0/</guid>
      <description>浮点数#从科学计数法的思想而来
表示#\[N = 尾数M \times 基数r^{阶码E}\]基数隐含是规定值，一般是2
尾数是定点小数，表现精度；阶码用以推算小数点位置，表现大小
规格化#10进制中要求尾数的第一个数为有效值，小数点在其后，在2进制中：
左规：尾数算术左移直到 第一位（除符号位为）为1，每移动1位阶码也要相应-1 右规：在运算时有效位走到小数点之前，所以需要右移，减小尾数增大阶数 运算#</description>
    </item>
    
    <item>
      <title>3.2 主存与CPU连接</title>
      <link>https://zvictorliu.github.io/computer_organization/mem/%E4%B8%BB%E5%AD%98%E4%B8%8Ecpu%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/computer_organization/mem/%E4%B8%BB%E5%AD%98%E4%B8%8Ecpu%E8%BF%9E%E6%8E%A5/</guid>
      <description>主存与CPU连接#这样的基本连接模型：
当CPU的DB和AB长度和存储器不一致时，需要进行扩展：
​	字扩展：增大存储单元数量
​	位扩展：增大存储芯片字长
单块#一块存储芯片：
地址线&amp;ndash;存储单元个数，数据线&amp;ndash;存储字长，控制线，片选线
而经常是总线数量比接口多，于是有位扩展和字扩展
多块#位扩展#每块只有一位 ($8K \times 1 bit$)，合起来
字扩展#扩展容量（AB比地址接口多，寻址能力没有充分发挥）
取高位地址为片选信号:
​	线选法：最直接的，有且只有一位使能，高位数量n对应块数量n，地址空间不连续（00 11这样的无效）
​	译码片选法：采用非门，能够利用的就更多了，高位数量n对应块数量$2^n$
字位同时扩展#横向是字扩展，纵向是位扩展
译码器#CPU的MAR送出地址信号，待稳定后CPU再发出存储器请求信号使能译码器，进一步使能存储器
即译码器有多个使能同时作用才有效：
说存储器容量表示为 xxB时是字数*字长的结果</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zvictorliu.github.io/computer_organization/encode/%E8%BF%90%E7%AE%97/%E4%B9%98%E9%99%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/computer_organization/encode/%E8%BF%90%E7%AE%97/%E4%B9%98%E9%99%A4/</guid>
      <description>乘法#原码一位乘法#符号位单独处理：取异或
先加，然后逻辑右移，移到符号位为止
符号位要修改，ACC和MQ当中处符号位之外的一起
手算方式补码一位乘法#Booth算法
MQ多一位辅助位在最后，ACC和X多一个双符号位在前面
在最后还会再加一次
在电路上，有专门的辅助电路帮助进行
除法#原码-恢复余数法#取绝对值进行计算，符号位单独来
设商为1，进行减法计算，发现为负值，恢复余数，改为0
逻辑左移
原码-加减交替法#补码-加减交替法#双符号位参与计算
最后一位商恒置为1
天，这里怎么可能记得住</description>
    </item>
    
    <item>
      <title>3.3 外存</title>
      <link>https://zvictorliu.github.io/computer_organization/mem/%E5%A4%96%E5%AD%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/computer_organization/mem/%E5%A4%96%E5%AD%98/</guid>
      <description>外存#磁盘（机械硬盘）#写：电流方向控制磁头上极性变换，再有磁性记录介质
读：切割磁感线
是每1bit的读写，且不能同时进行
非破坏性，介质可重复使用，长期保存
组成#盘片
一个记录面对应一个磁头，盘面上一圈一圈图上介质，为磁道
柱面号表示哪条磁道；扇区号表示哪个角度区间
以扇区为单位（但是1位1位的）
磁盘驱动器：驱动旋转
磁盘控制器：与主机的接口，有常见标准SATA
正反面都可以涂上：
指标#容量：
非格式化容量：物理上如果全用上的最大容量
格式化容量：留出一些备份区间，能用的最大容量
记录密度：
道密度：磁道数/半径
位密度：二进制码位数/磁道周长
面密度：位密度*道密度
每个扇区内的不同磁道的比特数是相等的，内侧位密度更大
平均存取时间：
寻道（磁头移动到对应磁道）$\rightarrow$ 旋转延迟（定位到扇区）$\rightarrow$ 传输时间，还可能算上控制命令的延迟
一般未明说旋转延迟按平均来说：转半圈
数据传输率：$D_r = 转速r \times 磁道容量N$
磁盘编址#驱动器号+磁道号+盘面号+扇区号
盘面号激活哪个磁头（磁头是一列整体移动的）
读写#总线并行，磁盘串行
串并转换，一位一位读写
磁盘阵列#廉价冗余磁盘阵列RAID
RAID0：连续的数据分在相邻的磁盘上，能够提高速度（不总在一个磁盘上操作），能进行访问；但没有容错能力
RAID1：镜像，安全性提高但减少了一般容量
RAID2：存海明校验码而不存copy，RAID3-5就是其它的校验码，可靠性更高
SSD（固态硬盘）#各个小芯片组成，基于闪存技术的EEPROM
以页为单位进行读写：逻辑块对应SSD块当中的页
按块擦除：当需要擦除某一页时是先把其它页复制到别的块再将整个块擦除
而写之前必须擦除，是复制后写在新的页中，块号是会变化的，闪存翻译层会重新映射
也支持随机访问（尽管是ROM），是电路定位，机械硬盘则不是时间均匀的（它写相对于读是慢的，但是相对于机械硬盘仍是很快的）
缺点是：擦除过多会坏掉，而机械硬盘则不会
闪存翻译层有一个平均磨损算法（迁移块时有考虑）
​	动态磨损均衡：每次迁移到磨损最少的块
​	静态磨损均衡：读多写少的数据放到比较老的块
不过，实际上寿命还是很长的，并没有那么容易坏</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zvictorliu.github.io/computer_organization/encode/%E8%BF%90%E7%AE%97/%E5%85%B6%E5%AE%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/computer_organization/encode/%E8%BF%90%E7%AE%97/%E5%85%B6%E5%AE%83/</guid>
      <description>C语言类型转换#C语言中定点整数都是补码表示（除非有unsigned）
有符号和无符号转换：理解方式不一样而已
不同字长：裁剪，符号扩展
存储和排列#大小端模式#大端：MSB存入低地址
小段：LSB存入低地址
边界对齐#字地址和字节地址
每次访存只能读写1个字
空间换时间</description>
    </item>
    
  </channel>
</rss>
