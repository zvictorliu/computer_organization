[{"id":0,"href":"/computer_organization/encode/%E8%BF%90%E7%AE%97/%E5%8A%A0%E5%87%8F/","title":"加减","section":"2.3 运算方法和电路","content":"\r加法器\r#\r宏观来看一个加法器应该是这样：\n一位全加器\r#\r$$ S_i = A_i \\oplus B_i \\oplus C_{i-1} \\\\ C_i = A_i B_i + (A_i \\oplus B_i)C_{i-1} $$ 电路设计\r↕\r串行进位全加器\r#\r并行进位加法器\r#\r对进位的公式进行了展开，发现了可以进行超前进位的特点，即：\n$C_i$ 只与 ${A_i}$，${B_i}$和$C_0$有关\n一般定义 $G_i = A_i B_i, \\quad P_i = A_i \\oplus B_i$\nCLA部件实现对进位的超前计算，全先行进位加法器的组成：\nCLA部件的电路\r↕\r可发现位数越高电路越复杂，一般也就到4位\r带标志位的加法器\r#\r定义了四个标志位：\n溢出标志OF：最高位的进位$C_i\\oplus$次高位的进位$C_{i-1}$（只对于有符号数运算有意义） 符号标志SF: 即结果最高位，0表示为正，1为负 （只对于有符号数运算有意义） 进or借位标志CF: $C_{out} \\oplus C_{in}$，即最高位进位和运算符(0为+)的异或 （无符号数有意义）是对无符号数判断是否溢出的标志，而有符号数是看OF 零标志ZF: 结果全为0时为1 补码加减\r#\r多路选择器MUX，运算控制信号进行选择，当为减法时选择 $\\bar{Y}$ 然后进位 $C_{in} = 1$，就实现了取反末位+1的处理\n同样也可以用于无符号的加减运算\n但是判断溢出的方法是不同的\n"},{"id":1,"href":"/computer_organization/encode/%E8%A1%A8%E7%A4%BA/","title":"2.1 整数和定点小数编码","section":"第二章 编码","content":"\r整数和定点小数编码\r#\r无符号整数\r#\r​\t机器字长决定位数上限\n​\t减法运算：减数取反，末位加1后做加法\n带符号整数（定点整数）\r#\r原码与补码\r#\r原码：符号位+数值位\n​\t表示范围和个数（0的两种）\n​\t符号位不能参与运算，硬件电路很麻烦成本很高，所以发明了补码\n反码：中间状态\n​\t负数：符号位不变，数值位取反\n补码：\n​\t负数：反码末位+1\n手算的原码补码快速转换快速方法：从右往左第一个1的左边数值位取反\n补码计算\r#\r注意：负数的补码不表示权值，人类无法直接阅读\n加法：诸位相加即可，符号位也参与运算\n减法：取负（无论正负，全部位按位取反末位+1）（从右往左第一个1，左边全部位取反）\n​\t这一点和无符号的减法是一致的，同一套电路即可实现\n特性对比\r#\r补码的表示范围：\r\\( -2^n \\sim 2^n -1 \\)\r，因为补码形式下0只有一种形式：0,000000，而1,0000000表示 \\(-2^n \\)\r，但却没有对应的原码和反码，因此转换规则不使用（或者直接是按位取反溢出不舍弃）\n移码\r#\r补码的符号位取反，等价于\r\\(x\u0026#43;2^n\\)\r，所以其表示范围也是\r\\( -2^n \\sim 2^n -1 \\)\r从小到达排列与无符号一致，使得比大小很方便，一般用于浮点数阶码表示，且只能表示整数\n定点小数\r#\r小数点位置固定为定点数（隐含的并不是真的空出来一位，根据相对位置确定），不固定为浮点数\n定点小数：纯小数，小数点在最高位之前\n定点整数：纯整数，小数点在最低位之前\n定点小数可以用原码、反码、补码表示，而不能用移码\n表示方法和计算和无符号也是一样的，表示范围看上去就是定点整数\r\\(/2^n\\)\r，在形式上完全一致，这就使得计算机的处理方式不变而只需要不同的理解\n"},{"id":2,"href":"/computer_organization/mem/%E4%B8%BB%E5%AD%98/","title":"3.1 主存","section":"第三章 存储系统","content":"\r主存\r#\r基本组成\r#\r半导体 - 存储芯片 - 寻址方式支持\n存储元：1位，MOS管和电容的组成，需要恢复时间的原因\n一次性读取or写入多个存储元的数据\n存储元 - 存储单元 - 存储矩阵（存储体）\n整个存储字是同时被接通的\n读：译码器将MAR中的数据转换位某条路上的高电平，使得对应存储单元中存储元们同时被选择；然后通过数据线写入到MDR中，CPU通过数据总线从MDR中取走\n控制电路：确保电信号稳定后再操作；片选；读写区分\n逻辑上的组成：\n片选线：多个存储矩阵时区分，实际内存条内是有多个存储芯片\n引脚：地址线、数据线、片选线、控制线的接口，还有供电和接地的 （控制线可能为两根或一根）\n按字节编址，一个字节对应一个地址\n而寻址可以按字节、字、半字、双字\n当按字寻址时，通过逻辑右移实现一次性跨越多个字节\nRAM\r#\r动态DRAM：栅极电容，静态SRAM：双稳态触发器\nSRAM能够保持状态，读出不需要再生，非破坏，速度块，但构造复杂成本高、面积大、功耗大；cache一般用这个\nDRAM则在读取后需要重写，是破坏性重写\n这两种芯片状态维持都需要电源，都是断电易失的\nDRAM还需要刷新：电容内电荷会随时间流失\nDRAM的刷新\r#\r行列地址方式： 减少选通线的数量\n一般一次刷新一行：硬件读取一行再写入\n每隔2ms进行一次刷新\n分散刷新：每次读写完就刷新一行 集中刷新：前面一直读取，之后留出时间来刷新，此时CPU无法访问，是为死区 异步刷新：在周期内每行只刷新一次，每隔一定间隔就刷新一行 DRAM还有地址线复用技术减少地址线（因为DRAM一般地址空间更大）：行地址和列地址分两次传入，先传入行，再存入列\n而SRAM地址空间小，就一次性传入\nROM\r#\r以下并不是说这属于主存\nMROM 掩模式只读存储器：厂家生产时写入之后无法更改\nPROM 可编程只读存储器，用户能写一次\nEPROM 可擦除课编程只读存储器，用户也能多次写入但比较麻烦\n​\tUVEPROM：紫外线方式，一次性擦除所有信息\n​\tEEPROM：电擦除特定的字\nFlash Memory 闪存：在EEPROM之上发展而来，擦除更快，但是写之前还是需要擦一遍，写会慢于读（比如U盘和SD卡）；它的存储元是单个MOS管，位密度比RAM高\nSSD固态硬盘：在闪存的基础上还有了控制单元\n所以现在说的ROM还真不是纯粹的read only，ROM也可能是随机存取的\n主板上的ROM芯片如BIOS芯片，也划在主存范围内，所以主存不只有内存(RAM)\n多模块技术\r#\r解决CPU的速度和主存的速度（受制于DRAM的长恢复时间）匹配问题 $$ 存储周期T = 存取时间r + 恢复时间 $$\n多体并行\r#\r多个模块，每个模块有各自的控制电路和寄存器\n高位交叉编址：体号+体内地址\n这种连续的单元在同一体内仍然是顺序的\n低位交叉编址：体号放后面低地址，这种才是交叉的\n这种则连续的单元并不是在同一体内\n模块数的确定：\nr为存取时间或总线传输周期（看哪个大）\n加装内存条就可以考虑是高位交叉（单纯扩容）还是低位交叉（双通道）\n单体多字\r#\r只有一个存储体，一次读取一整个存储单元（一整行），一个存储单元内有多个字\n灵活性要更差，当读取的内容跨越了一行后就需要读两次\n"},{"id":3,"href":"/computer_organization/introduction/","title":"第一章 绪论","section":"序","content":"\r绪论\r#\r计算机系统\r#\r计算机系统=硬件+软件，系统的性能主要由软件的效率表征，而软件的发挥与硬件有关\n软件与硬件在逻辑上等效，但硬件实现性能更好\n存储程序概念：指令以二进制形式送入主存，一旦启动就不需要人为干预，自动逐条执行指令\n冯·罗依曼体系结构：\n输入输出设备进行人识别信息-机器识别信息转换\n控制器执行指令的解析，运算器完成运算，指令和数据存放在存储器\n冯以运算器为中心，输入输出都需要经过运算器，影响了效率，所以现代计算机是以存储器为中心：\nCPU = 控制器+运算器，主机不包含辅助存储器（外存是外设）\n层次结构\r#\r计算机系统的多级层次结构，上层看上去是在直接操控计算机\n微指令：理解为硬件的动作\n高级语言 - 汇编语言 - 机器语言\n汇编器：汇编到机器语言 编译器：高级到汇编，有些可以直接到机器语言 解释器：将语句逐条翻译为机器指令（类似同声传译）然后执行，是命令行式的，Python就是这样只不过是脚本的形式 PC存放下一条指令的地址，IR存放当前的指令，从PC到IR需要MDR（存放欲访问的内存地址——，MIR暂存读出来的指令\n性能指标\r#\r主存容量：MAR位数（存储单元个数）和MDR位数（存储单元大小）\n运算速度：\nCPU主频：主时钟信号频率 CPU时钟周期不同于CPU周期（机器周期） CPI, Clock cycle Per Instruction：一条指令需要多少个时钟周期（一般看平均） CPU执行时间 IPS, Instrutions Per Second：每秒执行多条指令 （MIPS，每秒多少百万条） FLOPS, Floating-point Operations Per Second：每秒多少浮点操作 吞吐量：单位时间处理请求的数量（每种请求每钟吞吐量 响应时间 数据通路带宽：数据总线一次能并行传输的信息位数\n字长：进行一次整数运算所处理的二进制数据位数，一般看通用寄存器\n机器字长就是计算机位数，不同于操作系统位数（寻址） 基准程序：跑分软件，跑相同的代码比较性能\n"},{"id":4,"href":"/computer_organization/encode/%E8%BF%90%E7%AE%97/%E7%A7%BB%E4%BD%8D/","title":"移位","section":"2.3 运算方法和电路","content":"\r移位\r#\r算术移位（有符号数）\r#\r用原码： 即改变位权，对于定点数无法改变小数点位置，所以是向左向右补零，相当于乘除2\n当定点整数向右移动，舍弃的是1时就意味着舍弃了精度\n多想想这个表达式：\n同样也适用于定点小数\n用反码： 负数由于取反，补的是1\n用补码： 负数，最右边的1右边和原码一致，左边和反码一致，左右移动补的是不一样\n总结：\n逻辑移位\r#\r讲操作数视为无符号数进行算术移位\n循环移位\r#\r小循环：不带进位位CF\n大循环：带上CF一起循环\n"},{"id":5,"href":"/computer_organization/encode/%E6%B5%AE%E7%82%B9%E6%95%B0/","title":"2.2 浮点数","section":"第二章 编码","content":"\r浮点数\r#\r从科学计数法的思想而来\n表示\r#\r\\[\rN = 尾数M \\times 基数r^{阶码E}\r\\]\r基数隐含是规定值，一般是2\n尾数是定点小数，表现精度；阶码用以推算小数点位置，表现大小\n规格化\r#\r10进制中要求尾数的第一个数为有效值，小数点在其后，在2进制中：\n左规：尾数算术左移直到 第一位（除符号位为）为1，每移动1位阶码也要相应-1 右规：在运算时有效位走到小数点之前，所以需要右移，减小尾数增大阶数 运算\r#\r"},{"id":6,"href":"/computer_organization/mem/%E4%B8%BB%E5%AD%98%E4%B8%8Ecpu%E8%BF%9E%E6%8E%A5/","title":"3.2 主存与CPU连接","section":"第三章 存储系统","content":"\r主存与CPU连接\r#\r这样的基本连接模型：\n当CPU的DB和AB长度和存储器不一致时，需要进行扩展：\n​\t字扩展：增大存储单元数量\n​\t位扩展：增大存储芯片字长\n单块\r#\r一块存储芯片：\n地址线\u0026ndash;存储单元个数，数据线\u0026ndash;存储字长，控制线，片选线\n而经常是总线数量比接口多，于是有位扩展和字扩展\n多块\r#\r位扩展\r#\r每块只有一位 ($8K \\times 1 bit$)，合起来\n字扩展\r#\r扩展容量（AB比地址接口多，寻址能力没有充分发挥）\n取高位地址为片选信号:\n​\t线选法：最直接的，有且只有一位使能，高位数量n对应块数量n，地址空间不连续（00 11这样的无效）\n​\t译码片选法：采用非门，能够利用的就更多了，高位数量n对应块数量$2^n$\n字位同时扩展\r#\r横向是字扩展，纵向是位扩展\n译码器\r#\rCPU的MAR送出地址信号，待稳定后CPU再发出存储器请求信号使能译码器，进一步使能存储器\n即译码器有多个使能同时作用才有效：\n说存储器容量表示为 xxB时是字数*字长的结果\n"},{"id":7,"href":"/computer_organization/encode/","title":"第二章 编码","section":"序","content":"\r数据的表示和运算\r#\r进位计数\n进制转换：\n二进制与8进制、16进制（三位，四位一组） 10进制转： 整数部分：除K取余 小数部分：乘K取整 真值：带正负的数\n机器数：数字化后的真值\n"},{"id":8,"href":"/computer_organization/encode/%E8%BF%90%E7%AE%97/%E4%B9%98%E9%99%A4/","title":"乘除","section":"2.3 运算方法和电路","content":"\r乘法\r#\r原码一位乘法\r#\r符号位单独处理：取异或\n先加，然后逻辑右移，移到符号位为止\n符号位要修改，ACC和MQ当中处符号位之外的一起\n手算方式\r补码一位乘法\r#\rBooth算法\nMQ多一位辅助位在最后，ACC和X多一个双符号位在前面\n在最后还会再加一次\n在电路上，有专门的辅助电路帮助进行\n除法\r#\r原码-恢复余数法\r#\r取绝对值进行计算，符号位单独来\n设商为1，进行减法计算，发现为负值，恢复余数，改为0\n逻辑左移\n原码-加减交替法\r#\r补码-加减交替法\r#\r双符号位参与计算\n最后一位商恒置为1\n天，这里怎么可能记得住\n"},{"id":9,"href":"/computer_organization/encode/%E8%BF%90%E7%AE%97/","title":"2.3 运算方法和电路","section":"第二章 编码","content":"\r运算方法和电路\r#\rALU：Arithmetic and Logic Unit，能进行加减运算、逻辑运算和一些移位、取补的操作（控制信号指明）\n门电路实现与或非\n优先级：与 \u0026gt; 或\n"},{"id":10,"href":"/computer_organization/mem/%E5%A4%96%E5%AD%98/","title":"3.3 外存","section":"第三章 存储系统","content":"\r外存\r#\r磁盘（机械硬盘）\r#\r写：电流方向控制磁头上极性变换，再有磁性记录介质\n读：切割磁感线\n是每1bit的读写，且不能同时进行\n非破坏性，介质可重复使用，长期保存\n组成\r#\r盘片\n一个记录面对应一个磁头，盘面上一圈一圈图上介质，为磁道\n柱面号表示哪条磁道；扇区号表示哪个角度区间\n以扇区为单位（但是1位1位的）\n磁盘驱动器：驱动旋转\n磁盘控制器：与主机的接口，有常见标准SATA\n正反面都可以涂上：\n指标\r#\r容量：\n非格式化容量：物理上如果全用上的最大容量\n格式化容量：留出一些备份区间，能用的最大容量\n记录密度：\n道密度：磁道数/半径\n位密度：二进制码位数/磁道周长\n面密度：位密度*道密度\n每个扇区内的不同磁道的比特数是相等的，内侧位密度更大\n平均存取时间：\n寻道（磁头移动到对应磁道）$\\rightarrow$ 旋转延迟（定位到扇区）$\\rightarrow$ 传输时间，还可能算上控制命令的延迟\n一般未明说旋转延迟按平均来说：转半圈\n数据传输率：$D_r = 转速r \\times 磁道容量N$\n磁盘编址\r#\r驱动器号+磁道号+盘面号+扇区号\n盘面号激活哪个磁头（磁头是一列整体移动的）\n读写\r#\r总线并行，磁盘串行\n串并转换，一位一位读写\n磁盘阵列\r#\r廉价冗余磁盘阵列RAID\nRAID0：连续的数据分在相邻的磁盘上，能够提高速度（不总在一个磁盘上操作），能进行访问；但没有容错能力\nRAID1：镜像，安全性提高但减少了一般容量\nRAID2：存海明校验码而不存copy，RAID3-5就是其它的校验码，可靠性更高\nSSD（固态硬盘）\r#\r各个小芯片组成，基于闪存技术的EEPROM\n以页为单位进行读写：逻辑块对应SSD块当中的页\n按块擦除：当需要擦除某一页时是先把其它页复制到别的块再将整个块擦除\n而写之前必须擦除，是复制后写在新的页中，块号是会变化的，闪存翻译层会重新映射\n也支持随机访问（尽管是ROM），是电路定位，机械硬盘则不是时间均匀的（它写相对于读是慢的，但是相对于机械硬盘仍是很快的）\n缺点是：擦除过多会坏掉，而机械硬盘则不会\n闪存翻译层有一个平均磨损算法（迁移块时有考虑）\n​\t动态磨损均衡：每次迁移到磨损最少的块\n​\t静态磨损均衡：读多写少的数据放到比较老的块\n不过，实际上寿命还是很长的，并没有那么容易坏\n"},{"id":11,"href":"/computer_organization/mem/","title":"第三章 存储系统","section":"序","content":"\r存储系统\r#\r概述\r#\r存储器的分层次结构的意义：速度、容量\n存储器的分类\n性能指标：存取时间和存取周期的区别，需要恢复时间\n"},{"id":12,"href":"/computer_organization/instructions/","title":"第四章 指令系统","section":"序","content":"\r指令系统\r#\r"},{"id":13,"href":"/computer_organization/cpu/","title":"第五章 中央处理器","section":"序","content":"\rCPU\r#\r"},{"id":14,"href":"/computer_organization/bus/","title":"第六章 总线","section":"序","content":"\r总线\r#\r"},{"id":15,"href":"/computer_organization/io/","title":"第七章 IO系统","section":"序","content":"\rI/O系统\r#\r"},{"id":16,"href":"/computer_organization/encode/%E8%BF%90%E7%AE%97/%E5%85%B6%E5%AE%83/","title":"其它","section":"2.3 运算方法和电路","content":"\rC语言类型转换\r#\rC语言中定点整数都是补码表示（除非有unsigned）\n有符号和无符号转换：理解方式不一样而已\n不同字长：裁剪，符号扩展\n存储和排列\r#\r大小端模式\r#\r大端：MSB存入低地址\n小段：LSB存入低地址\n边界对齐\r#\r字地址和字节地址\n每次访存只能读写1个字\n空间换时间\n"}]